<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.2/dist/full.min.css" rel="stylesheet" type="text/css"/>
	<style>
		#voice-command {
            position: relative;
            z-index: 9999;
        }
        #voice-command.listening {
            background-color: #f44336;
        }
		.navbar {
			z-index: 9999;
		}
	</style>
	<script src="https://cdn.tailwindcss.com"></script>
	<script defer src="src/auto_theme.js"></script>
	<script defer src="src/populate_data.js"></script>
	<title>PlayPal - Chat</title>
</head>
<body class="h-screen flex flex-col h-full">
	<!--Navbar start-->
	<div class="navbar bg-base-100">
		<div class="navbar-start">
			<a class="btn btn-ghost text-xl" href="history.html">PlayPal</a>
			<!--Menu Button start-->
			<a class="btn btn-ghost text-xl" href="history.html">
				<div class="" role="button" tabindex="0">
					<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"
						xmlns="http://www.w3.org/2000/svg">
						<path d="M4 6h16M4 12h8m-8 6h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"/>
					</svg>
				</div>
			</a>
			<!--Menu Button end-->
		</div>
		<div class="navbar-center flex">
			<ul class="menu menu-horizontal px-1">
				<li>
					<!--Chat Name start-->
					<details>
						<summary id="chat_title">Chat name is here</summary>
						<ul class="p-2">
							<li><a>Rename Chat</a></li>
							<!--todo: implement-->
							<li><a class="text-error">Delete Chat</a></li>
							<!--todo: implement (local storage remove)-->
						</ul>
					</details>
					<!--Chat Name end-->
				</li>
			</ul>
		</div>
		<div class="navbar-end">
			<a class="btn" href="new.html">New Chat</a>
		</div>
	</div>
	<!--Navbar end-->

	<!-- Main container start -->
	<div class="flex flex-1 w-full overflow-hidden">
		<!-- Summary panel start -->
		<div id="summary-panel" class="w-1/3 bg-neutral transition-all duration-300 ease-in-out flex flex-col relative">
			<div class="flex-1 p-4 bg-neutral" style="color: white;" id="summary-content">
					Created February 29, 2024<br>
					Last Chat: March 10, 2024<br>
					<br>
					Key takeaways:<br>
					- Crosshair Placement: Always keep the crosshair at head level and anticipate enemy positions to minimize reaction time when engaging.<br>
					- Map Awareness: Learn common map callouts and develop a habit of checking minimap regularly to anticipate enemy rotations and plan strategic movements.<br>
					- Utility Usage: Understand the utility of your chosen agent and utilize it effectively to control space, gather information, and support teammates.<br>
					- Communication: Communicate clearly with teammates about enemy positions, intentions, and strategies. Effective communication enhances teamwork and coordination.<br>
			</div>
		</div>
		<!-- Summary panel end -->

		<!-- Collapse Button start -->
		<button
			id="collapse-button"
			class="text-gray-600 bg-transparent hover:bg-primary hover:text-white p-2"
		>
			&lt;
		</button>
		<!-- Collapse Button end -->

		<!-- Chat panel start -->
		<div id="chat-panel" class="w-2/3 transition-all duration-300 ease-in-out flex flex-col relative justify-start">
			

			<!-- Chat Content start -->
			<div id="chat-content" class="flex-1 p-4 overflow-auto"></div>
			<!-- Chat Content end -->

			<!-- Chat Button -->
			<!-- Microphone -->
			<div class="flex justify-center p-4">
				<button type="button" class="btn btn-primary" id="voice-command">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-mic" viewBox="0 0 16 16">
						<path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5"/>
						<path d="M10 8a2 2 0 1 1-4 0V3a2 2 0 1 1 4 0zM8 0a3 3 0 0 0-3 3v5a3 3 0 0 0 6 0V3a3 3 0 0 0-3-3"/>
					</svg>
				</button>
			</div>
		</div>
		<!-- Chat panel end -->

		
	</div>
	<!-- Main container end -->
</body>

<script>
	// summary panel collapse functionality
	const collapseButton = document.getElementById('collapse-button');
	const summaryPanel = document.getElementById('summary-panel');
	const summaryContent = document.getElementById('summary-content');
	const chatPanel = document.getElementById('chat-panel');
	

	let isCollapsed = false;

	collapseButton.addEventListener('click', () => {
		if (isCollapsed) {
			// Expand the summary panel
			summaryPanel.classList.remove('w-0');
			summaryPanel.classList.add('w-1/3');
			summaryContent.classList.remove('hidden');
			chatPanel.classList.remove('w-full');
			chatPanel.classList.add('w-2/3');
			collapseButton.textContent = '<'; 
		} else {
			// Collapse the summary panel
			summaryPanel.classList.remove('w-1/3');
			summaryPanel.classList.add('w-0');
			summaryContent.classList.add('hidden');
			chatPanel.classList.remove('w-2/3');
			chatPanel.classList.add('w-full');
			collapseButton.textContent = '>';
		}
		isCollapsed = !isCollapsed;
	});

	/* grab conversation history from local storage */
	const currentConversationID = localStorage.getItem("currentConversationID");
	let convObj = JSON.parse(localStorage.getItem(currentConversationID));
	const companionPersona = convObj.AI_Persona;
	const gameName = convObj.Game_Name;
	// const chatsObj = JSON.parse(localStorage.getItem("chat_list"));
	// let companionPersona;
	// for (let i = 0; i < chatsObj.chat_list.length; i++) {
	// 	if (chatsObj.chat_list[i].ID === currentConversationID) {
	// 		companionPersona = chatsObj.chat_list[i].AI_Persona;
	// 		break;
	// 	}
	// }

	function displayChatSummary() {
		const convObj = JSON.parse(localStorage.getItem(currentConversationID));
		document.getElementById("chat_title").textContent = convObj.Title;
		document.getElementById("summary-content").textContent = convObj.Summary;
	}

	async function updateChatSummary() {
		// find the chat in the chat list
		const chatList = JSON.parse(localStorage.getItem("chat_list")).chat_list;
		for (let i = 0; i < chatList.length; i++) {
			if (chatList[i].ID === currentConversationID) {
				// if the summary date is before the last chat date, update the summary
				if (chatList[i].Summary_Date < chatList[i].Last_Chat) {
					// ask the API for a new summary and title
					const response = await fetch(
						'https://noggin.rea.gent/main-possum-7776',
						{
							method: 'POST',
							headers: {
								'Content-Type': 'application/json',
								Authorization: 'Bearer rg_v1_np2u0in5myj8s4li9ls0dqgoteyk8i4mwiqa_ngk',
							},
							body: JSON.stringify({
								"history": localStorage.getItem(currentConversationID),
							}),
						}
					).then(response => response.json());

					const new_title = response.title;
					const new_summary = response.summary;

					// update the chat list object in local storage
					chatList[i].Title = new_title;
					chatList[i].Summary = new_summary;
					chatList[i].Summary_Date = new Date().toJSON();
					localStorage.setItem("chat_list", JSON.stringify({chat_list: chatList}));

					// update the chat detail object in local storage
					let convObject = JSON.parse(localStorage.getItem(currentConversationID));
					convObject.Title = new_title;
					convObject.Summary = new_summary;
					localStorage.setItem(currentConversationID, JSON.stringify(convObject));

					displayChatSummary()
				}
				break;
			}
		}
	}

	updateChatSummary()

	function loadChatHistory() {
		let convJson = localStorage.getItem(currentConversationID);
		let convObject = JSON.parse(convJson);
		console.log(convObject); // test
		
		convObject.Chat_History.forEach((message) => {
			if (message.role === "user") {
				appendUserMessage(message.content);
			}
			else if (message.role !== "system") {
				appendCompanionMessage(message.content);
			}
		});
	}
	
	loadChatHistory();
	


	// speech recognition logic
	const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
	const voiceCommand = document.getElementById("voice-command");
	const recognition = new SpeechRecognition();

	recognition.continuous = false;
	recognition.lang = "en-US";
	recognition.interimResults = false;
	recognition.maxAlternatives = 1;

	voiceCommand.onclick = () => {
		if (!recognition.ongoing) {
			recognition.start();
			voiceCommand.classList.add("listening");
		}
	};

	function updateGameLast_Played() {
		const gameList = JSON.parse(localStorage.getItem("game_list")).game_list;
		for (let i = 0; i < gameList.length; i++) {
			if (gameList[i].Game_Name === gameName) {
				gameList[i].Last_Played = new Date().toJSON();
				break;
			}
		}
		localStorage.setItem("game_list", JSON.stringify({game_list: gameList}));
	}

	function updatePersonaLast_Chat() {
		const personaList = JSON.parse(localStorage.getItem("persona_list")).persona_list;
		for (let i = 0; i < personaList.length; i++) {
			if (personaList[i].Persona_Name === companionPersona) {
				personaList[i].Last_Chat = new Date().toJSON();
				break;
			}
		}
		localStorage.setItem("persona_list", JSON.stringify({persona_list: personaList}));
	}

	function updateChatLast_Chat() {
		const chatList = JSON.parse(localStorage.getItem("chat_list")).chat_list;
		for (let i = 0; i < chatList.length; i++) {
			if (chatList[i].ID === currentConversationID) {
				chatList[i].Last_Chat = new Date().toJSON();
				break;
			}
		}
		localStorage.setItem("chat_list", JSON.stringify({chat_list: chatList}));
	}

	// add a message to chat history in local storage
	function updateChatHistory(role, content) {
		let convJson = localStorage.getItem(currentConversationID);
		let convObj = JSON.parse(convJson);

		const newUserMessage = {
			role: role,
			content: content
		};

		convObj.Chat_History.push(newUserMessage);

		updateGameLast_Played();
		updatePersonaLast_Chat();
		updateChatLast_Chat();

		const updatedConvJson = JSON.stringify(convObj);
		localStorage.setItem(currentConversationID, updatedConvJson);
	}

	// append a new user message to the page
	function appendUserMessage(message) {
		const chatContent = document.getElementById("chat-content");

		const userMessage = document.createElement("div");
		userMessage.className = "chat chat-end";

		const avatar = document.createElement("div");
		avatar.className = "chat-image avatar";
		const avatarImage = document.createElement("div");
		avatarImage.className = "w-10 rounded-full";
		avatarImage.innerHTML = '<img alt="Tailwind CSS chat bubble component" src="https://static.vecteezy.com/system/resources/previews/008/442/086/non_2x/illustration-of-human-icon-user-symbol-icon-modern-design-on-blank-background-free-vector.jpg" />'
		avatar.appendChild(avatarImage);

		const chatBubble = document.createElement("div");
		chatBubble.className = "chat-bubble";
		chatBubble.textContent = message;

		userMessage.appendChild(avatar);
		userMessage.appendChild(chatBubble);

		chatContent.appendChild(userMessage);

		// scroll to bottom of chat
		chatContent.scrollToop = chatContent.scrollHeight;
	}

	// append a new companion message to the page
	function appendCompanionMessage(message) {
		// add message to webpage
		const chatContent = document.getElementById("chat-content");

		const companionMessage = document.createElement("div");
		companionMessage.className = "chat chat-start"; 

		const avatar = document.createElement("div");
		avatar.className = "chat-image avatar";
		const avatarImage = document.createElement("div");
		avatarImage.className = "w-10 rounded-full";
		avatarImage.innerHTML = '<img alt="Companion avatar" src="https://i.pinimg.com/originals/a5/39/07/a53907b134abfe7fdc26da8eeef1e268.jpg" />';
		avatar.appendChild(avatarImage);

		const chatBubble = document.createElement("div");
		chatBubble.className = "chat-bubble response";
		chatBubble.textContent = message;

		companionMessage.appendChild(avatar);
		companionMessage.appendChild(chatBubble);

		chatContent.appendChild(companionMessage);

		// scroll to bottom of chat
		chatContent.scrollToop = chatContent.scrollHeight;
	}

	// generate a response to the latest user message
	// requires local storage to be updated with the latest user message first!
	async function getCompanionResponse() {
		// send all historical messages to the API
		// const historicalMessages = JSON.parse(localStorage.getItem(currentConversationID)).Chat_History;
		const response = await fetch(
			'https://noggin.rea.gent/entire-ermine-9121',
			{
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					Authorization: 'Bearer rg_v1_gbgypjwk1bk7lsel8il4zfjfr6a7718rlp8o_ngk',
				},
				body: JSON.stringify({
					// fill variables here.
					"userMsg": localStorage.getItem(currentConversationID),
				}),
			}
		).then(response => response.text());
		return response;
	}

	recognition.onresult = async (event) => {
		const transcript = event.results[0][0].transcript;

		appendUserMessage(transcript);
		updateChatHistory("user", transcript);
		const companionMessage = await getCompanionResponse();

		// handel if user transcript was irrelevant
		if (!companionMessage.startsWith("skip") && !companionMessage.startsWith("Skip") && companionMessage !== "..." && companionMessage !== "") {
			appendCompanionMessage(companionMessage);
			updateChatHistory(companionPersona, companionMessage);
		} // else: irrelevant message, do nothing
	};

	recognition.onend = () => {
		voiceCommand.classList.remove("listening");
		recognition.ongoing = false;
	};

	recognition.onerror = (event) => {
		voiceCommand.classList.remove("listening");
		console.error('Speech recognition error:', event.error);
	};

	//Outputs the response as a speech
	const speechSynth = window.speechSynthesis;
    const speakButton = document.getElementById("speak-button");

	document.addEventListener('DOMContentLoaded', function() {
		const targetNode = document.getElementById('chat-content');
		const config = { childList: true, subtree: true };

		const observer = new MutationObserver(function(mutations) {
			mutations.forEach(function(mutation) {
				mutation.addedNodes.forEach(function(node) {
					if (node.nodeType === 1 && node.querySelector('.response')) { 
						const messages = node.querySelectorAll('.response');
						messages.forEach(msg => {
							const speech = new SpeechSynthesisUtterance(msg.textContent);
							speechSynth.speak(speech);
						});
					}
				});
			});
		});

		observer.observe(targetNode, config);
    });

</script>
</html>